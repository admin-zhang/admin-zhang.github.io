<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="alternate" href="/rss.xml" title="" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="" type="application/atom+xml"><link rel="alternate" type="application/json" title="" href="http://blog.icoders.club/feed.json"><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"><link rel="preconnect" href="https://at.alicdn.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext" media="none" onload="this.media='all'"><link rel="stylesheet" href="/css/app.css?v=0.4.2"><link rel="modulepreload" href="/js/chunk-2N4DYD35.js"><link rel="modulepreload" href="/js/chunk-ECZ3LG5D.js"><link rel="modulepreload" href="/js/chunk-I6CY6N4A.js"><link rel="modulepreload" href="/js/chunk-KZSKOY4M.js"><link rel="modulepreload" href="/js/chunk-QWLQUKSX.js"><link rel="modulepreload" href="/js/comments-AUNHBEKV.js"><link rel="modulepreload" href="/js/index.esm-O6LQS4SE.js"><link rel="modulepreload" href="/js/post-NR3WVKIL.js"><link rel="modulepreload" href="/js/quicklink-BQPWQUOJ.js"><link rel="modulepreload" href="/js/search-BBWMP3LS.js"><link rel="modulepreload" href="/js/siteInit.js"><link rel="stylesheet" href="https://npm.webcache.cn/@waline/client@3.0.0-alpha.11/dist/waline.css" media="none" onload="this.media='all'"><link rel="preload" href="https://i.imgtg.com/2023/03/09/YQSYM.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://i.imgtg.com/2023/03/09/Y0xvg.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://i.imgtg.com/2023/03/09/YS2LU.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://i.imgtg.com/2023/03/09/Y0kTl.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://i.imgtg.com/2023/03/09/Y0iNK.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://i.imgtg.com/2023/03/09/Y0zdB.jpg" as="image" fetchpriority="high"><meta name="keywords" content="Java,ChatGPT"><link rel="canonical" href="http://blog.icoders.club/java-interview-basics-01/"><title>Java模拟面试题-基础篇-01</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Java模拟面试题-基础篇-01</h1><div class="meta"><span class="item" title="创建时间：2025-07-29 21:51:14"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2025-07-29T21:51:14+08:00">2025-07-29</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>21k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>19 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">碎银几两</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" style="background-image: url(&quot;https://i.imgtg.com/2023/03/09/YQSYM.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://i.imgtg.com/2023/03/09/Y0xvg.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://i.imgtg.com/2023/03/09/YS2LU.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://i.imgtg.com/2023/03/09/Y0kTl.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://i.imgtg.com/2023/03/09/Y0iNK.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://i.imgtg.com/2023/03/09/Y0zdB.jpg&quot;);"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement="" itemscope="" itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/java/" itemprop="item" rel="index" title="分类于Java"><span itemprop="name">Java<meta itemprop="position" content="0"></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/java/interview/" itemprop="item" rel="index" title="分类于面试"><span itemprop="name">面试<meta itemprop="position" content="1"></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.icoders.club/java-interview-basics-01/"><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.png"><meta itemprop="name" content="张大爷"><meta itemprop="description" content="以梦为马，不负韶华, "></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h2 id="java-面试模拟系列"><a class="anchor" href="#java-面试模拟系列">#</a> Java 面试模拟系列 🧠📘</h2>
<blockquote>
<p>该系列文档基于真实面试准备过程，通过 ChatGPT 辅助问答，对高频 Java 面试题进行整理与答疑。每篇文档聚焦一个主题，覆盖基础、集合、JVM、并发、网络等模块。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>文章标题</th>
<th>内容简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td><a href="/java-interview-basics-01/" title="Java模拟面试题-基础篇-01">Java 模拟面试题(基础篇01)</a></td>
<td>Java 基础知识模拟问答</td>
</tr>
<tr>
<td>02</td>
<td><a href="/java-interview-question-01/" title="Java模拟面试题（1）">Java 模拟面试题(1)</a></td>
<td>集合框架、JMM 内存模型等基础进阶题</td>
</tr>
<tr>
<td>03</td>
<td><a href="/java-interview-question-02/" title="Java模拟面试题（2）">Java 模拟面试题(2)</a></td>
<td>Java 四种引用类型等进阶题</td>
</tr>
<tr>
<td>...</td>
<td>🔄 持续更新中</td>
<td>JVM、并发、Spring 等模块</td>
</tr>
</tbody>
</table>
<hr>
<p>📌 推荐使用场景：</p>
<ul>
<li>准备面试前的快速复盘</li>
<li>学习 Java 各模块的知识要点</li>
<li>与 ChatGPT 配合自测提问训练</li>
</ul>
<p>🚀 持续优化中，欢迎 Star &amp; 分享！</p>
</blockquote>
<h2 id="java-基础与进阶"><a class="anchor" href="#java-基础与进阶">#</a> 💡Java 基础与进阶</h2>
<h3 id="问题1java-中-和-equals-的区别请举例说明"><a class="anchor" href="#问题1java-中-和-equals-的区别请举例说明">#</a> ❓问题 1：Java 中  <code>==</code>  和  <code>equals()</code>  的区别？请举例说明。</h3>
<blockquote>
<p>详解可参考： <a href="/String-in-Java/" title="深入理解 Java 中的 == 和 equals()（面试高频）">深入理解 Java 中的 == 和 equals()</a></p>
</blockquote>
<h4 id="分析可从如下角度进行回答"><a class="anchor" href="#分析可从如下角度进行回答">#</a> ✨分析：可从如下角度进行回答</h4>
<ul>
<li>对于基本类型 vs 引用类型</li>
<li>equals 默认行为及如何重写</li>
<li>常见面试陷阱，如 String 比较</li>
</ul>
<h4 id="答案"><a class="anchor" href="#答案">#</a> ✅答案：</h4>
<p>在 Java 中， <code>==</code>  和  <code>equals()</code>  的区别主要体现在<strong>基本数据类型</strong>与<strong>引用类型</strong>的处理上：</p>
<h5 id="对于基本类型"><a class="anchor" href="#对于基本类型">#</a> 🧩 对于基本类型：</h5>
<ul>
<li><code>==</code>  比较的是<strong>值是否相等</strong>。</li>
<li><code>equals()</code>  ❌ 不适用于基本类型（编译报错）</li>
</ul>
<h5 id="对于引用类型"><a class="anchor" href="#对于引用类型">#</a> 🧩 对于引用类型：</h5>
<ul>
<li><code>==</code>  比较的是<strong>引用地址</strong>，也就是是否指向同一个对象。</li>
<li><code>equals()</code>  默认继承自  <code>Object</code>  类，<strong>也是比较引用地址</strong>；<br>
但许多类（如  <code>String</code> 、 <code>Integer</code> 、 <code>List</code> ）都重写了  <code>equals()</code>  方法，用来比较对象的<strong>内容</strong>是否相等。</li>
</ul>
<h5 id="示例代码"><a class="anchor" href="#示例代码">#</a> ✅ 示例代码：</h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//false（不同对象）</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true（内容相同）</span></pre></td></tr></tbody></table></figure><h4 id="追问stringintern-方法的作用是什么它与-有什么关系"><a class="anchor" href="#追问stringintern-方法的作用是什么它与-有什么关系">#</a> 📌 追问： <code>String.intern()</code>  方法的作用是什么？它与  <code>==</code>  有什么关系？</h4>
<p><code>String.intern()</code>  是一个<strong> native 方法</strong>，它的作用是：</p>
<blockquote>
<p><strong>如果常量池中已经存在与当前字符串内容相同的字符串，则返回该字符串的引用；否则将当前字符串添加到常量池，并返回这个常量池中的引用。</strong></p>
</blockquote>
<p>因此，调用  <code>intern()</code>  后，我们可以使用  <code>==</code>  来比较是否为同一对象引用（即是否引用了常量池中的同一字符串）。</p>
<h5 id="示例代码-2"><a class="anchor" href="#示例代码-2">#</a> 🔍 示例代码：</h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//false（s1 是堆中对象，s2 是常量池）</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//true（s1.intern () 返回常量池引用）</span></pre></td></tr></tbody></table></figure><hr>
<h4 id="总结"><a class="anchor" href="#总结">#</a> 🧾 总结：</h4>
<ul>
<li><code>==</code>  比较的是<strong>引用地址</strong>；</li>
<li><code>equals()</code> （在重写后）比较的是<strong>对象内容</strong>；</li>
<li><code>intern()</code>  用于<strong>将字符串放入常量池</strong>，从而可以使用  <code>==</code>  来比较字符串内容是否相同（前提是都来自常量池）。</li>
</ul>
<h3 id="问题2-java-的八种基本数据类型是什么它们各自的默认值是什么"><a class="anchor" href="#问题2-java-的八种基本数据类型是什么它们各自的默认值是什么">#</a> ❓问题 2： Java 的八种基本数据类型是什么？它们各自的默认值是什么？</h3>
<p>Java 有 <strong>8 种基本数据类型</strong>，分为<strong>四类</strong>：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用字节</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1 byte</td>
<td>0</td>
<td>整型，-128~127</td>
</tr>
<tr>
<td>short</td>
<td>2 bytes</td>
<td>0</td>
<td>整型</td>
</tr>
<tr>
<td>int</td>
<td>4 bytes</td>
<td>0</td>
<td>整型，默认整型</td>
</tr>
<tr>
<td>long</td>
<td>8 bytes</td>
<td>0L</td>
<td>长整型</td>
</tr>
<tr>
<td>float</td>
<td>4 bytes</td>
<td>0.0f</td>
<td>单精度浮点型</td>
</tr>
<tr>
<td>double</td>
<td>8 bytes</td>
<td>0.0d</td>
<td>双精度浮点型</td>
</tr>
<tr>
<td>char</td>
<td>2 bytes</td>
<td>'\u0000'</td>
<td>字符类型</td>
</tr>
<tr>
<td>boolean</td>
<td>1 bit*</td>
<td>false</td>
<td>布尔类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p>说明：boolean 实际上是由 JVM 实现决定占用空间，通常是 1 byte，而不是真正的 1 bit。</p>
</blockquote>
<h4 id="追问为什么-char-占两个字节java-中的-char-能表示哪些字符你对-unicode-的理解"><a class="anchor" href="#追问为什么-char-占两个字节java-中的-char-能表示哪些字符你对-unicode-的理解">#</a> <strong>📌 追问：为什么  <code>char</code>  占两个字节？Java 中的  <code>char</code>  能表示哪些字符？你对 Unicode 的理解？</strong></h4>
<h5 id="分析"><a class="anchor" href="#分析">#</a> ✨ 分析：</h5>
<p>请从以下几个方面作答：</p>
<ul>
<li><code>char</code>  在 Java 中占多少字节，为什么？</li>
<li>Java 使用哪种字符集？</li>
<li>Unicode 和 UTF-8 有什么关系？</li>
<li>是否能表示中文、表情符等字符？</li>
</ul>
<h5 id="为什么-char-占两个字节"><a class="anchor" href="#为什么-char-占两个字节">#</a> 🔹 为什么  <code>char</code>  占两个字节？</h5>
<p>在 Java 中， <code>char</code>  类型是 <strong>无符号的 16 位整数（2 字节）</strong>，用于表示一个<strong> Unicode 编码的字符</strong>（Unicode 编号范围从  <code>\u0000</code>  到  <code>\uFFFF</code> ，即 0~65535）。</p>
<p>当时设计这样是为了支持国际化，尤其是中文、日文、韩文等字符。</p>
<hr>
<h5 id="java-中使用什么字符编码"><a class="anchor" href="#java-中使用什么字符编码">#</a> 🔹 Java 中使用什么字符编码？</h5>
<p>Java 使用的是 <strong>Unicode 编码体系</strong>，内部使用 <strong>UTF-16</strong> 编码表示字符。</p>
<ul>
<li><code>char</code>  表示的是一个 UTF-16 单元（16-bit），所以最多只能直接表示 BMP（Basic Multilingual Plane，基本多文种平面）内的字符（即  <code>\u0000</code>  ~  <code>\uFFFF</code> ）；</li>
<li>如果是扩展字符（如 emoji 表情 😊，Unicode 超过 0xFFFF），则需要两个  <code>char</code>  表示一个字符（称为 <strong>代理对 Surrogate Pair</strong>）。</li>
</ul>
<hr>
<h5 id="unicode-vs-utf-8-vs-utf-16"><a class="anchor" href="#unicode-vs-utf-8-vs-utf-16">#</a> 🔹 Unicode vs UTF-8 vs UTF-16</h5>
<table>
<thead>
<tr>
<th>编码</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unicode</td>
<td>一种字符集，给每个字符分配唯一编码编号</td>
</tr>
<tr>
<td>UTF-8</td>
<td>可变长编码（1~4 字节），常用于网络和文件存储</td>
</tr>
<tr>
<td>UTF-16</td>
<td>可变长编码（2 或 4 字节），Java 内部使用该编码方式</td>
</tr>
<tr>
<td>char</td>
<td>Java 中使用 UTF-16 单元，每个 char 占 2 字节</td>
</tr>
</tbody>
</table>
<hr>
<h5 id="举个例子"><a class="anchor" href="#举个例子">#</a> 🔍 举个例子：</h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">'中'</span><span class="token punctuation">;</span>              <span class="token comment">// 占 2 字节，对应 Unicode \u4E2D</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> emoji <span class="token operator">=</span> <span class="token string">"😊"</span><span class="token punctuation">;</span>       <span class="token comment">// 实际占用两个 char，因为 Unicode 超过 0xFFFF</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>emoji<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 2</span></pre></td></tr></tbody></table></figure><hr>
<h5 id="小结"><a class="anchor" href="#小结">#</a> 📌 小结：</h5>
<ul>
<li><code>char</code>  是 2 字节，因为使用 UTF-16 单元。</li>
<li>Java 使用 Unicode 编码，支持中文。</li>
<li>一个  <code>char</code>  并不等于一个字符，尤其是在 emoji 表情或特殊语言字符时。</li>
</ul>
<h3 id="问题3string-stringbuilder-和-stringbuffer-有什么区别它们各自的适用场景"><a class="anchor" href="#问题3string-stringbuilder-和-stringbuffer-有什么区别它们各自的适用场景">#</a> ❓问题 3：String、StringBuilder 和 StringBuffer 有什么区别？它们各自的适用场景？</h3>
<h4 id="string不可变对象"><a class="anchor" href="#string不可变对象">#</a> 🔹 String（不可变对象）</h4>
<ul>
<li>定义： <code>final</code>  类，内容不可变，每次修改都会创建新对象。</li>
<li>特点：线程安全、效率较低（频繁拼接时容易产生大量中间对象）。</li>
<li>场景：适用于字符串内容不会频繁变化的场景，如常量、配置参数等。</li>
</ul>
<h4 id="stringbuilder可变非线程安全"><a class="anchor" href="#stringbuilder可变非线程安全">#</a> 🔹 StringBuilder（可变，非线程安全）</h4>
<ul>
<li>定义：可变字符串容器，底层使用  <code>char[]</code>  实现。</li>
<li>特点：非线程安全，但性能高。</li>
<li>场景：<strong>单线程环境</strong>下频繁修改字符串的操作（如拼接、插入等）。</li>
</ul>
<h4 id="stringbuffer可变线程安全"><a class="anchor" href="#stringbuffer可变线程安全">#</a> 🔹 StringBuffer（可变，线程安全）</h4>
<ul>
<li>定义：与  <code>StringBuilder</code>  类似，但<strong>方法加了 synchronized</strong>，保证线程安全。</li>
<li>特点：性能比  <code>StringBuilder</code>  略低，但在多线程下更安全。</li>
<li>场景：<strong>多线程环境</strong>下操作字符串。</li>
</ul>
<hr>
<h4 id="性能对比"><a class="anchor" href="#性能对比">#</a> ✅ 性能对比：</h4>
<table>
<thead>
<tr>
<th>操作对象</th>
<th>线程安全</th>
<th>性能</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>✅ 是</td>
<td>❌ 低</td>
<td>不变字符串</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>❌ 否</td>
<td>✅ 高</td>
<td>单线程字符串拼接</td>
</tr>
<tr>
<td>StringBuffer</td>
<td>✅ 是</td>
<td>⚠ 中等</td>
<td>多线程字符串拼接</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="追问进阶你知道-string-为什么是不可变的吗它不可变的好处是什么"><a class="anchor" href="#追问进阶你知道-string-为什么是不可变的吗它不可变的好处是什么">#</a> 📌 追问（进阶）：你知道 String 为什么是不可变的吗？它不可变的好处是什么？</h4>
<h5 id="为什么-string-是不可变的"><a class="anchor" href="#为什么-string-是不可变的">#</a> 🔹 为什么 String 是不可变的？</h5>
<ol>
<li><strong>底层结构</strong>
<ul>
<li><code>String</code>  内部使用  <code>final char[] value</code>  来存储字符；</li>
<li><code>final</code>  保证引用不可变，整个  <code>String</code>  对象内容不能更改。</li>
</ul>
</li>
<li><strong>类被 final 修饰</strong>
<ul>
<li><code>String</code>  是一个  <code>final</code>  类，不能被继承；</li>
<li>防止子类修改其不可变语义（如重写  <code>hashCode()</code>  等）。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="不可变的好处"><a class="anchor" href="#不可变的好处">#</a> 🔒 不可变的好处：</h5>
<ol>
<li><strong>安全性</strong>
<ul>
<li>比如将字符串用于文件路径、网络地址、数据库连接等敏感操作，内容不可更改能避免安全漏洞。</li>
</ul>
</li>
<li><strong>线程安全</strong>
<ul>
<li>不需要额外同步，在多线程下天然安全。</li>
</ul>
</li>
<li><strong>缓存优化</strong>
<ul>
<li>可以使用字符串常量池（String Pool），提升性能，减少内存开销。</li>
</ul>
</li>
<li><strong>可作为 HashMap 的 key</strong>
<ul>
<li>不可变性保证  <code>hashCode</code>  一致性，HashMap 等容器可安全使用。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">String</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//abc（未变）</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//xbc（新对象）</span></pre></td></tr></tbody></table></figure><h5 id="小结-2"><a class="anchor" href="#小结-2">#</a> ✅ 小结：</h5>
<ul>
<li><code>String</code>  不可变，底层是  <code>final char[]</code> ；</li>
<li>类本身是  <code>final</code> ，不能被继承；</li>
<li>不可变带来线程安全、性能优化、可安全作为 key 等多重优势。</li>
</ul>
<h3 id="问题4java-中是值传递还是引用传递请解释-string-基本类型-对象类型在方法中的传参行为"><a class="anchor" href="#问题4java-中是值传递还是引用传递请解释-string-基本类型-对象类型在方法中的传参行为">#</a> ❓问题 4：Java 中是值传递还是引用传递？请解释 String、基本类型、对象类型在方法中的传参行为。</h3>
<p>🔹 Java 中<strong>只有值传递（pass-by-value）</strong>，但根据类型不同表现略有差异：</p>
<h4 id="一-基本数据类型如-int-double-boolean"><a class="anchor" href="#一-基本数据类型如-int-double-boolean">#</a> 一、基本数据类型（如  <code>int</code> ,  <code>double</code> ,  <code>boolean</code> ）</h4>
<ul>
<li>方法调用时，<strong>传的是值的副本</strong>。</li>
<li>在方法内修改，不会影响原始变量。</li>
</ul>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">change</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 5</span></pre></td></tr></tbody></table></figure><h4 id="二-引用类型如-string-自定义对象等"><a class="anchor" href="#二-引用类型如-string-自定义对象等">#</a> 二、引用类型（如  <code>String</code> , 自定义对象等）</h4>
<ul>
<li>方法调用时，<strong>传的是对象引用的副本</strong>（仍然是值传递）。</li>
<li>在方法内通过该引用可以修改对象的属性，但不能改变原始引用本身的指向。</li>
</ul>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">String</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token class-name">Person</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    p<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>     <span class="token comment">// ✅ 修改了属性</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ❌ 改变了指向，仅对方法内有效</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    p<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Tom"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Lucy"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">change</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 Jack（不是 Tom）</span></pre></td></tr></tbody></table></figure><hr>
<h4 id="三-特殊说明string-是不可变对象"><a class="anchor" href="#三-特殊说明string-是不可变对象">#</a> 三、特殊说明： <code>String</code>  是不可变对象</h4>
<p>即使是引用类型，但由于不可变（ <code>final</code>  +  <code>char[]</code> ），在方法中重新赋值是无效的：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    s <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">change</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 Hello</span></pre></td></tr></tbody></table></figure><hr>
<h4 id="结论口诀可以背"><a class="anchor" href="#结论口诀可以背">#</a> ✅ 结论口诀（可以背）：</h4>
<blockquote>
<p>Java 全是值传递，<br>
基本类型传数值，<br>
引用类型传地址的副本，<br>
改属性能改，改引用没用！</p>
</blockquote>
<h3 id="问题4请说一下-java-中的继承和多态是如何实现的能举例说明一下吗"><a class="anchor" href="#问题4请说一下-java-中的继承和多态是如何实现的能举例说明一下吗">#</a> ❓问题 4：请说一下 Java 中的继承和多态是如何实现的？能举例说明一下吗？</h3>
<h4 id="继承inheritance"><a class="anchor" href="#继承inheritance">#</a> 🔷 继承（Inheritance）</h4>
<p>Java 使用  <code>extends</code>  关键字实现类的继承。</p>
<ul>
<li>子类继承父类的非私有成员（字段、方法）。</li>
<li>支持单继承，但类可以实现多个接口。</li>
</ul>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"动物叫"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"狗叫"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><hr>
<h4 id="多态polymorphism"><a class="anchor" href="#多态polymorphism">#</a> 🔷 多态（Polymorphism）</h4>
<p>多态分为两类：</p>
<h5 id="1-编译时多态方法重载-overload"><a class="anchor" href="#1-编译时多态方法重载-overload">#</a> ✅ 1. 编译时多态（方法重载 Overload）：</h5>
<ul>
<li>同一个类中，方法名相同，<strong>参数列表不同</strong>（类型或数量不同）；</li>
<li>与返回值无关；</li>
<li>属于<strong>静态绑定</strong>，在编译期间确定调用哪个方法。</li>
</ul>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><hr>
<h5 id="2-运行时多态方法重写-override"><a class="anchor" href="#2-运行时多态方法重写-override">#</a> ✅ 2. 运行时多态（方法重写 Override）：</h5>
<ul>
<li>子类重写父类方法（方法签名必须相同）；</li>
<li>调用时根据对象的实际类型决定执行哪个方法；</li>
<li>属于<strong>动态绑定</strong>，在运行时确定。</li>
</ul>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">Animal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 向上转型</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a<span class="token punctuation">.</span><span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 输出 “狗叫”，即使 a 是 Animal 类型</span></pre></td></tr></tbody></table></figure><blockquote>
<p>✔ 运行时多态的核心：<strong>父类引用指向子类对象 + 方法重写 + 动态绑定</strong></p>
</blockquote>
<hr>
<h4 id="结论口诀"><a class="anchor" href="#结论口诀">#</a> ✅ 结论口诀：</h4>
<blockquote>
<p><strong>继承用 extends，多态靠 override，引用指向父类，执行看子类。</strong></p>
</blockquote>
<h4 id="补充说明"><a class="anchor" href="#补充说明">#</a> ❗ 补充说明：</h4>
<ol>
<li><strong>方法重载（Overload）</strong> 其实<strong>不是多态的体现</strong>，它是<strong>编译时的多态</strong>（静态绑定）；</li>
<li>真正的<strong>运行时多态</strong> 是通过<strong>方法重写 + 向上转型 + 动态绑定</strong>实现的。</li>
</ol>
<h4 id="追问进阶"><a class="anchor" href="#追问进阶">#</a> 📌 追问（进阶）：</h4>
<p>你知道 Java 中方法重写时，访问修饰符和异常可以变动吗？比如父类方法抛出异常，子类能否不抛或抛其他的？</p>
<h5 id="1-访问修饰符可以改变但有限制"><a class="anchor" href="#1-访问修饰符可以改变但有限制">#</a> 🔹1. <strong>访问修饰符可以改变，但有限制：</strong></h5>
<ul>
<li>子类重写方法的访问级别<strong>不能更严格</strong>；</li>
<li>但<strong>可以更宽松</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>父类方法修饰符</th>
<th>子类允许的修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td><code>public</code></td>
</tr>
<tr>
<td><code>protected</code></td>
<td><code>protected</code> ,  <code>public</code></td>
</tr>
<tr>
<td>默认（包访问）</td>
<td>默认、 <code>protected</code> 、 <code>public</code></td>
</tr>
<tr>
<td><code>private</code></td>
<td>❌ 不能被重写（不是重写，是新方法）</td>
</tr>
</tbody>
</table>
<hr>
<h5 id="2-异常处理可以改变但有限制"><a class="anchor" href="#2-异常处理可以改变但有限制">#</a> 🔹2. <strong>异常处理：可以改变，但有限制：</strong></h5>
<ul>
<li>父类方法<strong>没有抛出异常</strong>：子类方法<strong>不能抛出检查型异常</strong>（Checked Exception），可以抛运行时异常（Unchecked）；</li>
<li>父类方法抛出某个<strong>检查型异常</strong>：子类方法只能抛出<strong>相同或更小（子类）范围的异常</strong>；</li>
<li>子类方法<strong>可以不抛出异常</strong>，即使父类抛出了异常。</li>
</ul>
<hr>
<h5 id="举个例子说明"><a class="anchor" href="#举个例子说明">#</a> ✅ 举个例子说明：</h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// OK（FileNotFoundException 是 IOException 子类）</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RuntimeException</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// OK（抛运行时异常）</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ❌ 编译错误（父类不抛，子类不能新增 Checked 异常）</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><hr>
<h5 id="小结口诀"><a class="anchor" href="#小结口诀">#</a> ✅ 小结口诀：</h5>
<blockquote>
<ul>
<li>访问控制：只能放宽不能收紧；</li>
<li>异常抛出：只可少不可多，<strong>Checked 异常需兼容</strong>；</li>
<li><code>private</code>  方法不能重写，它是子类自己的新方法。</li>
</ul>
</blockquote>
<h3 id="问题5java-中的异常分为哪两类如何处理它们分别举个例子"><a class="anchor" href="#问题5java-中的异常分为哪两类如何处理它们分别举个例子">#</a> ❓问题 5：Java 中的异常分为哪两类？如何处理它们？分别举个例子。</h3>
<h4 id="java-中的异常分为两类"><a class="anchor" href="#java-中的异常分为两类">#</a> 🔷 Java 中的异常分为两类：</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>分类别名</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CheckedException</strong></td>
<td>编译时异常（受检异常）</td>
<td>必须在代码中显式处理（try-catch 或 throws）</td>
</tr>
<tr>
<td><strong>UncheckedException</strong></td>
<td>运行时异常（非受检异常）</td>
<td>编译器不会强制处理，程序运行时可能抛出</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="一-checked-exception受检异常"><a class="anchor" href="#一-checked-exception受检异常">#</a> ✅ 一、Checked Exception（受检异常）</h4>
<ul>
<li>继承自  <code>Exception</code> ，但<strong>不包括 RuntimeException</strong>；</li>
<li>编译器强制要求处理；</li>
<li>例如：
<ul>
<li><code>IOException</code></li>
<li><code>SQLException</code></li>
<li><code>ParseException</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可能抛 IOException</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><hr>
<h4 id="二-unchecked-exception非受检异常"><a class="anchor" href="#二-unchecked-exception非受检异常">#</a> ✅ 二、Unchecked Exception（非受检异常）</h4>
<ul>
<li>继承自  <code>RuntimeException</code> ；</li>
<li>编译器不要求强制捕获；</li>
<li>常见如：
<ul>
<li><code>NullPointerException</code></li>
<li><code>ArrayIndexOutOfBoundsException</code></li>
<li><code>IllegalArgumentException</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运行时抛出 NullPointerException</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><hr>
<h4 id="三-异常处理方式"><a class="anchor" href="#三-异常处理方式">#</a> ✅ 三、异常处理方式</h4>
<h5 id="1-try-catch-finally"><a class="anchor" href="#1-try-catch-finally">#</a> 1. try-catch-finally</h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">try</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 有风险的代码</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 异常处理</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 无论是否异常，最终执行</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><h5 id="2-throws-关键字方法签名抛出异常"><a class="anchor" href="#2-throws-关键字方法签名抛出异常">#</a> 2. throws 关键字（方法签名抛出异常）</h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 把异常继续往外抛，由调用者处理</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><h5 id="3-throw-抛出异常对象"><a class="anchor" href="#3-throw-抛出异常对象">#</a> 3. throw 抛出异常对象</h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"参数非法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><h4 id="小结口诀-2"><a class="anchor" href="#小结口诀-2">#</a> ✅ 小结口诀：</h4>
<blockquote>
<ul>
<li>Checked 必须处理，Unchecked 看你愿不愿意；</li>
<li>try-catch 用于捕，throws 把锅往外推；</li>
<li>finally 永远执行（除非  <code>System.exit(0)</code> ）。</li>
</ul>
</blockquote>
<hr>
<h4 id="追问"><a class="anchor" href="#追问">#</a> 📌 追问：</h4>
<p>你知道 finally 中 return 会覆盖 try 或 catch 中的 return 吗？是否继续？</p>
<h5 id="finally-的执行原则"><a class="anchor" href="#finally-的执行原则">#</a> 🔹  <code>finally</code>  的执行原则：</h5>
<ul>
<li>无论是否发生异常， <code>finally</code>  块都会执行；</li>
<li>如果  <code>try</code>  或  <code>catch</code>  中有  <code>return</code> ，而  <code>finally</code>  也有  <code>return</code> ，<strong>最终返回的是  <code>finally</code>  中的值</strong>；</li>
<li>如果  <code>finally</code>  中没有  <code>return</code> ，则执行完  <code>finally</code>  后仍返回  <code>try</code>  或  <code>catch</code>  中的值；</li>
<li><code>System.exit(0)</code>  会直接终止 JVM， <code>finally</code>  不会被执行。</li>
</ul>
<hr>
<h5 id="示例代码-3"><a class="anchor" href="#示例代码-3">#</a> ✅ 示例代码：</h5>
<h6 id="情况1finally-无-return不影响返回值"><a class="anchor" href="#情况1finally-无-return不影响返回值">#</a> 🎯 情况 1：finally 无 return，不影响返回值</h6>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">try</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finally 执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 输出：finally 执行</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 返回：1</span></pre></td></tr></tbody></table></figure><h6 id="情况2finally-有-return会覆盖-try-的-return"><a class="anchor" href="#情况2finally-有-return会覆盖-try-的-return">#</a> 🎯 情况 2：finally 有 return，会覆盖 try 的 return</h6>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">try</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 返回：2（覆盖了 try 的 return）</span></pre></td></tr></tbody></table></figure><h6 id="情况3systemexit"><a class="anchor" href="#情况3systemexit">#</a> 🎯 情况 3：System.exit ()</h6>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">try</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// JVM 终止</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finally"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不执行</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><hr>
<h5 id="小结口诀-3"><a class="anchor" href="#小结口诀-3">#</a> ✅ 小结口诀：</h5>
<blockquote>
<p>finally 永远会执行，<br>
有 return 就把结果替，<br>
try catch 返回全作废，<br>
exit 一出谁都不配。</p>
</blockquote>
<h3 id="问题6arraylist-和-linkedlist-有哪些区别它们各自的适用场景是什么"><a class="anchor" href="#问题6arraylist-和-linkedlist-有哪些区别它们各自的适用场景是什么">#</a> ❓问题 6：ArrayList 和 LinkedList 有哪些区别？它们各自的适用场景是什么？</h3>
<h4 id="1-arraylist"><a class="anchor" href="#1-arraylist">#</a> 🔹 1. ArrayList</h4>
<ul>
<li><strong>底层结构</strong>：动态数组（Object []）</li>
<li><strong>优点</strong>：
<ul>
<li>支持快速随机访问（O (1)）</li>
<li>查询性能高</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>插入 / 删除效率低（中间位置会整体移动元素）</li>
<li>扩容有一定性能开销（每次扩容为原来的 1.5 倍）</li>
</ul>
</li>
</ul>
<h4 id="2-linkedlist"><a class="anchor" href="#2-linkedlist">#</a> 🔹 2. LinkedList</h4>
<ul>
<li><strong>底层结构</strong>：双向链表（每个节点有 prev/next 指针）</li>
<li><strong>优点</strong>：
<ul>
<li>插入 / 删除性能高（只需改变前后指针）</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>不支持随机访问，查询效率低（O (n)）</li>
<li>占用内存较大（需要额外存储指针）</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-适用场景对比"><a class="anchor" href="#3-适用场景对比">#</a> ✅ 3. 适用场景对比</h4>
<table>
<thead>
<tr>
<th>场景类型</th>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody>
<tr>
<td>频繁读 / 查询</td>
<td>✅ 非常适合（O (1)）</td>
<td>❌ 慢（O (n)）</td>
</tr>
<tr>
<td>频繁增删（中间）</td>
<td>❌ 需要元素移动</td>
<td>✅ 只改指针</td>
</tr>
<tr>
<td>随机访问</td>
<td>✅ 快</td>
<td>❌ 慢</td>
</tr>
<tr>
<td>内存占用</td>
<td>更省</td>
<td>更高（额外指针）</td>
</tr>
</tbody>
</table>
<h4 id="举个例子-2"><a class="anchor" href="#举个例子-2">#</a> ✅ 举个例子：</h4>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> linkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>arrayList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 快</span></pre></td></tr><tr><td data-num="5"></td><td><pre>linkedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 慢（要从头或尾一个个遍历）</span></pre></td></tr></tbody></table></figure><h4 id="补充细节"><a class="anchor" href="#补充细节">#</a> 📌 补充细节：</h4>
<ul>
<li><strong>线程安全性</strong>：两者都不是线程安全的，可以使用  <code>Collections.synchronizedList()</code>  包装；</li>
<li><strong>插入性能对比</strong>：ArrayList 在尾部添加性能也很高，但在中间插入时就不如 LinkedList。</li>
</ul>
<hr>
<h4 id="小结口诀-4"><a class="anchor" href="#小结口诀-4">#</a> ✅ 小结口诀：</h4>
<blockquote>
<p>ArrayList 查找快，LinkedList 插入佳，<br>
查询随机选 Array，增删频繁用 Link，<br>
两者都不线程安，需包装才万全。</p>
</blockquote>
<h4 id="追问arraylist-的扩容机制具体是怎么实现的初始容量是多少"><a class="anchor" href="#追问arraylist-的扩容机制具体是怎么实现的初始容量是多少">#</a> 📌 追问：ArrayList 的扩容机制具体是怎么实现的？初始容量是多少？</h4>
<h5 id="1-默认初始容量是多少"><a class="anchor" href="#1-默认初始容量是多少">#</a> 🔹 1. 默认初始容量是多少？</h5>
<ul>
<li>
<p><strong>JDK 1.8 开始</strong>， <code>ArrayList</code>  的初始容量为 <strong>0</strong>，但<strong>第一次添加元素时自动扩容为 10</strong>；</p>
</li>
<li>
<p>这是为了避免创建不必要的数组，提高性能；</p>
</li>
<li>
<p>相关源码字段：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_CAPACITY</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure></li>
</ul>
<hr>
<h5 id="2-扩容触发条件"><a class="anchor" href="#2-扩容触发条件">#</a> 🔹 2. 扩容触发条件</h5>
<p>当调用  <code>add()</code>  方法插入元素时，如果当前元素个数已经达到数组容量上限，就会触发扩容。</p>
<hr>
<h5 id="3-扩容机制增长规则"><a class="anchor" href="#3-扩容机制增长规则">#</a> 🔹 3. 扩容机制（增长规则）</h5>
<ul>
<li>
<p>从 JDK 1.8 开始，<strong>扩容策略为原容量的 1.5 倍</strong>：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 即 oldCapacity * 1.5</span></pre></td></tr></tbody></table></figure></li>
<li>
<p>比如：</p>
<ul>
<li>容量 10 -&gt; 扩容后为 15</li>
<li>容量 15 -&gt; 扩容后为 22</li>
</ul>
</li>
<li>
<p>源码位置： <code>ArrayList.grow(int minCapacity)</code></p>
</li>
</ul>
<hr>
<h5 id="4-扩容代价性能影响"><a class="anchor" href="#4-扩容代价性能影响">#</a> 🔹 4. 扩容代价（性能影响）</h5>
<p>扩容时会：</p>
<ul>
<li>创建一个更大的新数组；</li>
<li>将原数组中的所有元素 <strong>使用  <code>System.arraycopy()</code>  拷贝</strong> 到新数组；</li>
<li>所以扩容操作的<strong>时间复杂度是 O (n)</strong>，在大数据量下性能开销较大；</li>
<li>实际项目中如果可预估数据量，建议<strong>提前指定初始容量</strong>以避免频繁扩容。</li>
</ul>
<hr>
<h5 id="小结口诀-5"><a class="anchor" href="#小结口诀-5">#</a> ✅ 小结口诀：</h5>
<blockquote>
<p>初始容量默认十，<br>
满了扩容乘一五；<br>
grow 方法来扩张，<br>
拷贝迁移代价高。</p>
</blockquote>
<h3 id="问题7hashmap-的底层实现原理是什么jdk-18-做了哪些优化"><a class="anchor" href="#问题7hashmap-的底层实现原理是什么jdk-18-做了哪些优化">#</a> ❓问题 7：HashMap 的底层实现原理是什么？JDK 1.8 做了哪些优化？</h3>
<h4 id="一-hashmap-的底层结构变化"><a class="anchor" href="#一-hashmap-的底层结构变化">#</a> 🔷 一、HashMap 的底层结构变化</h4>
<h5 id="jdk-17-及以前"><a class="anchor" href="#jdk-17-及以前">#</a> JDK 1.7 及以前：</h5>
<ul>
<li><strong>底层结构：数组 + 链表</strong></li>
<li>每个桶（bucket）是一个链表，链表中的每个节点是一个 Entry 对象，包含  <code>key</code> ,  <code>value</code> ,  <code>hash</code> ,  <code>next</code></li>
<li>发生哈希冲突时，多个 Entry 以链表形式挂载到同一个数组索引下</li>
</ul>
<h5 id="jdk-18-之后"><a class="anchor" href="#jdk-18-之后">#</a> JDK 1.8 之后：</h5>
<ul>
<li><strong>底层结构：数组 + 链表 + 红黑树</strong></li>
<li>当单个桶中的链表长度超过阈值（默认是 8），并且数组长度 ≥ 64 时，链表会被转换为 <strong>红黑树</strong></li>
<li>红黑树查询效率为 O (log n)，提高了性能</li>
</ul>
<hr>
<h4 id="二-核心成员结构源码层面"><a class="anchor" href="#二-核心成员结构源码层面">#</a> 🔷 二、核心成员结构（源码层面）</h4>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span> <span class="token comment">// 数组，默认初始容量 16</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">// 链表转红黑树的阈值</span></pre></td></tr></tbody></table></figure><ul>
<li>
<p>Node 是 Entry 的替代类，结构基本一致；</p>
</li>
<li>
<p>put 时先计算 hash 值，定位数组索引；</p>
<ul>
<li>
<p>如果当前位置为空，直接插入；</p>
</li>
<li>
<p>如果不为空（发生冲突），则：</p>
<ul>
<li>链表中遍历 key 是否已存在；</li>
<li>如果链表长度超过 TREEIFY_THRESHOLD（8），并且 table.length ≥ 64，则转为红黑树。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="三-hashmap-的主要优化jdk-18"><a class="anchor" href="#三-hashmap-的主要优化jdk-18">#</a> 🔷 三、HashMap 的主要优化（JDK 1.8）</h4>
<table>
<thead>
<tr>
<th>优化点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>红黑树引入</td>
<td>冲突严重时，链表结构变为红黑树，查询更快（O (n)→O (logn))</td>
</tr>
<tr>
<td>延迟初始化</td>
<td>table 数组不在构造函数中立即分配，而是在首次使用时初始化（节省内存）</td>
</tr>
<tr>
<td>hash 计算优化</td>
<td>使用扰动函数  <code>hash(key.hashCode())</code>  减少冲突</td>
</tr>
<tr>
<td>节点结构变化</td>
<td><code>Entry</code>  改为  <code>Node</code> ，更通用、清晰</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="小结口诀-6"><a class="anchor" href="#小结口诀-6">#</a> ✅ 小结口诀：</h4>
<blockquote>
<p>HashMap 数组链表挂，<br>
冲突一多树来刷；<br>
链长八、容量满，<br>
红黑上阵效率大。<br>
七改八，一变多，<br>
JDK8 才是红黑家。</p>
</blockquote>
<h4 id="追问hashmap-是线程安全的吗并发场景下会出现什么问题如何解决"><a class="anchor" href="#追问hashmap-是线程安全的吗并发场景下会出现什么问题如何解决">#</a> 📌追问：HashMap 是线程安全的吗？并发场景下会出现什么问题？如何解决？</h4>
<h5 id="1-hashmap-是线程安全的吗"><a class="anchor" href="#1-hashmap-是线程安全的吗">#</a> 🔷 1. HashMap 是线程安全的吗？</h5>
<p>❌ <strong>不是线程安全的。</strong></p>
<ul>
<li>多线程环境下同时调用  <code>put()</code> 、 <code>resize()</code>  等方法时会引发数据不一致、死循环等问题；</li>
<li>JDK 1.7 曾出现链表形成<strong>环形结构</strong>，导致死循环（CPU 100%）；</li>
</ul>
<hr>
<h5 id="2-并发情况下的问题"><a class="anchor" href="#2-并发情况下的问题">#</a> 🔷 2. 并发情况下的问题：</h5>
<table>
<thead>
<tr>
<th>问题</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据丢失</td>
<td>多个线程同时 put，后写入的会覆盖先写的值</td>
</tr>
<tr>
<td>数据覆盖</td>
<td>Hash 冲突时覆盖已有节点</td>
</tr>
<tr>
<td>死循环（JDK 1.7）</td>
<td>多线程扩容时链表节点移动顺序不一致，可能形成环链表，导致 get () 死循环</td>
</tr>
</tbody>
</table>
<hr>
<h5 id="3-解决方案"><a class="anchor" href="#3-解决方案">#</a> 🔷 3. 解决方案：</h5>
<h6 id="方式一使用-collectionssynchronizedmapmap"><a class="anchor" href="#方式一使用-collectionssynchronizedmapmap">#</a> ✅ 方式一：使用 <strong> <code>Collections.synchronizedMap(Map)</code> </strong></h6>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><ul>
<li>简单线程安全封装，但效率较低，所有操作加锁</li>
</ul>
<h6 id="方式二使用-concurrenthashmap"><a class="anchor" href="#方式二使用-concurrenthashmap">#</a> ✅ 方式二：使用 <strong> <code>ConcurrentHashMap</code> </strong></h6>
<ul>
<li>是 JDK 提供的线程安全的哈希表</li>
<li>适用于高并发读写场景</li>
</ul>
<hr>
<h5 id="4-concurrenthashmap-的底层原理以-jdk-18-为例"><a class="anchor" href="#4-concurrenthashmap-的底层原理以-jdk-18-为例">#</a> 🔷 4.  <code>ConcurrentHashMap</code>  的底层原理（以 JDK 1.8 为例）：</h5>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>分段锁机制废弃</td>
<td>不再使用 JDK 1.7 的 Segment 分段锁结构</td>
</tr>
<tr>
<td>采用 <strong>CAS + synchronized</strong></td>
<td>保证线程安全， <code>putVal()</code>  用 synchronized 锁住桶节点</td>
</tr>
<tr>
<td>红黑树优化</td>
<td>与 HashMap 一样，链表长度超过 8 转为红黑树</td>
</tr>
<tr>
<td>并发扩容机制</td>
<td>多线程协作扩容，提高效率</td>
</tr>
</tbody>
</table>
<hr>
<h5 id="小结口诀-7"><a class="anchor" href="#小结口诀-7">#</a> ✅ 小结口诀：</h5>
<blockquote>
<p>HashMap 并发不保险，死循环卡 CPU；<br>
覆盖丢失都可能，线程安全用 Concurrent；<br>
CAS 再加 S 锁，性能线程都保障。</p>
</blockquote>
<h5 id="衍生追问高级面试你知道-concurrenthashmap-为什么不能用来做-count-累加操作吗它是线程安全的为什么-还是不安全"><a class="anchor" href="#衍生追问高级面试你知道-concurrenthashmap-为什么不能用来做-count-累加操作吗它是线程安全的为什么-还是不安全">#</a> 📌 衍生追问（高级面试）：你知道 ConcurrentHashMap 为什么不能用来做 count++ 累加操作吗？它是线程安全的，为什么 ++ 还是不安全？</h5>
<p>虽然 <strong>ConcurrentHashMap 的 put/get 操作是线程安全的</strong>，但  <code>count++</code>  并不是一个原子操作，依然<strong>存在竞态条件</strong>。</p>
<hr>
<h6 id="原因count-并不是原子操作它分三步"><a class="anchor" href="#原因count-并不是原子操作它分三步">#</a> 🔷 原因： <code>count++</code>  并不是原子操作，它分三步：</h6>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><p>等价于：</p>
<ol>
<li>读取旧值： <code>int old = map.get("key")</code></li>
<li>计算新值： <code>int newVal = old + 1</code></li>
<li>写入新值： <code>map.put("key", newVal)</code></li>
</ol>
<p>如果多个线程同时执行，会发生如下问题：</p>
<ul>
<li>都读取到相同的旧值；</li>
<li>分别加 1 得到相同的新值；</li>
<li>最终结果被覆盖，<strong>增加的次数比实际少</strong>，即出现 “丢更新”。</li>
</ul>
<hr>
<h6 id="正确做法"><a class="anchor" href="#正确做法">#</a> 🔷 正确做法 ✅：</h6>
<p>方式 1：使用  <code>AtomicInteger</code></p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>map<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 原子自增，线程安全</span></pre></td></tr></tbody></table></figure><blockquote>
<p>✅ 这是最推荐的做法，原子性强、性能好。</p>
</blockquote>
<hr>
<p>方式 2：使用  <code>compute()</code>  方法（JDK8+）</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>map<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> v <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><ul>
<li>compute 内部加锁处理，保证原子性；</li>
<li>更适合做复杂的聚合操作。</li>
</ul>
<hr>
<h6 id="小结口诀-8"><a class="anchor" href="#小结口诀-8">#</a> ✅ 小结口诀：</h6>
<blockquote>
<p>Map 是线程安全，操作不等于原子；<br>
三步变一步，才是并发王道；<br>
要加就用 Atomic，要聚就用 compute。</p>
</blockquote>
<h3 id="问题8set-是如何保证元素不重复的hashset-的底层实现原理是什么"><a class="anchor" href="#问题8set-是如何保证元素不重复的hashset-的底层实现原理是什么">#</a> ❓问题 8：Set 是如何保证元素不重复的？HashSet 的底层实现原理是什么？</h3>
<h4 id="1-set-是如何保证元素不重复的"><a class="anchor" href="#1-set-是如何保证元素不重复的">#</a> 🔷 1. Set 是如何保证元素不重复的？</h4>
<p>在 Java 中：</p>
<ul>
<li><code>Set</code>  是一个接口，其常见实现类如  <code>HashSet</code> 、 <code>TreeSet</code> 、 <code>LinkedHashSet</code> ；</li>
<li>它的核心特性是：<strong>不允许元素重复</strong>；</li>
<li>实现去重的关键，是依赖元素的  <code>hashCode()</code>  和  <code>equals()</code>  方法。</li>
</ul>
<hr>
<h4 id="2-hashset-的底层原理"><a class="anchor" href="#2-hashset-的底层原理">#</a> 🔷 2. HashSet 的底层原理：</h4>
<h5 id="hashset-底层其实就是一个-hashmap"><a class="anchor" href="#hashset-底层其实就是一个-hashmap">#</a> ✅ HashSet 底层其实就是一个  <code>HashMap</code></h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅用作占位符</span></pre></td></tr></tbody></table></figure><ul>
<li>
<p>当你执行  <code>hashSet.add(e)</code>  时，其实等价于：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure></li>
<li>
<p>所以元素是否重复，取决于：</p>
<ul>
<li><code>e.hashCode()</code>  是否一样；</li>
<li>如果一样，再调用  <code>e.equals()</code>  判断是否相等。</li>
</ul>
</li>
</ul>
<h5 id="注意"><a class="anchor" href="#注意">#</a> ⚠ 注意：</h5>
<ul>
<li>如果你自定义对象放入  <code>HashSet</code> ，<strong>一定要重写  <code>equals()</code>  和  <code>hashCode()</code>  方法</strong>；</li>
<li>否则可能出现 “逻辑重复但实际不重复” 的情况。</li>
</ul>
<hr>
<h4 id="3-hashset-插入过程简述"><a class="anchor" href="#3-hashset-插入过程简述">#</a> 🔷 3. HashSet 插入过程简述：</h4>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>hashSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> → </pre></td></tr><tr><td data-num="2"></td><td><pre>    element<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> → </pre></td></tr><tr><td data-num="3"></td><td><pre>        定位桶 → </pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 比较 → </pre></td></tr><tr><td data-num="5"></td><td><pre>                不存在：加入</pre></td></tr><tr><td data-num="6"></td><td><pre>                存在：忽略（<span class="token class-name">Set</span> 不允许重复）</pre></td></tr></tbody></table></figure><hr>
<h4 id="举个例子-3"><a class="anchor" href="#举个例子-3">#</a> ✅ 举个例子：</h4>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第二次添加会被忽略</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 1</span></pre></td></tr></tbody></table></figure><hr>
<h4 id="小结口诀-9"><a class="anchor" href="#小结口诀-9">#</a> ✅ 小结口诀：</h4>
<blockquote>
<p>HashSet 本质 Map，值用哨兵 PRESENT；<br>
判重复靠 hash + equals，<br>
自定义对象别忘了重写方法！</p>
</blockquote>
<h4 id="追问treeset-是如何实现去重和排序的底层用的是什么结构"><a class="anchor" href="#追问treeset-是如何实现去重和排序的底层用的是什么结构">#</a> 📌 追问：TreeSet 是如何实现去重和排序的？底层用的是什么结构？</h4>
<h5 id="1-treeset-是什么"><a class="anchor" href="#1-treeset-是什么">#</a> 🔷 1. TreeSet 是什么？</h5>
<ul>
<li><code>TreeSet</code>  是  <code>Set</code>  接口的实现类；</li>
<li>它的特点是：
<ul>
<li><strong>元素自动排序（默认升序）</strong></li>
<li><strong>不允许重复元素</strong></li>
<li>查询、插入、删除都是 <strong>O(log n)</strong> 的效率</li>
</ul>
</li>
</ul>
<h5 id="2-treeset-的底层结构"><a class="anchor" href="#2-treeset-的底层结构">#</a> 🔷 2. TreeSet 的底层结构：</h5>
<p>TreeSet 的底层是基于 <strong> <code>TreeMap</code>  实现的红黑树（Red-Black Tree）</strong></p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">NavigableMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><ul>
<li>
<p>添加元素： <code>add(e)</code>  实际上调用的是：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure></li>
<li>
<p>因此，TreeSet 的本质是：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span></pre></td></tr></tbody></table></figure></li>
</ul>
<hr>
<h5 id="3-排序-去重的依据"><a class="anchor" href="#3-排序-去重的依据">#</a> 🔷 3. 排序 &amp; 去重的依据</h5>
<h6 id="默认排序"><a class="anchor" href="#默认排序">#</a> 默认排序：</h6>
<ul>
<li>元素必须实现  <code>Comparable</code>  接口，重写  <code>compareTo()</code>  方法；</li>
<li>如果元素无法比较（没有实现 Comparable），则会抛出  <code>ClassCastException</code> 。</li>
</ul>
<h6 id="自定义排序"><a class="anchor" href="#自定义排序">#</a> 自定义排序：</h6>
<ul>
<li>
<p>可以在构造 TreeSet 时传入  <code>Comparator</code>  比较器：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getAge</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure></li>
</ul>
<h6 id="去重的依据"><a class="anchor" href="#去重的依据">#</a> 去重的依据：</h6>
<ul>
<li><strong>不是  <code>equals()</code>  和  <code>hashCode()</code> ，而是  <code>compareTo()</code>  或  <code>Comparator.compare()</code>  的返回值是否为 0</strong>；</li>
<li>如果返回 0，则认为是重复元素，<strong>不会插入</strong>。</li>
</ul>
<hr>
<h5 id="举个例子-4"><a class="anchor" href="#举个例子-4">#</a> ✅ 举个例子：</h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不会加入</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]，自动排序 + 去重</span></pre></td></tr></tbody></table></figure><hr>
<h5 id="小结口诀-10"><a class="anchor" href="#小结口诀-10">#</a> ✅ 小结口诀：</h5>
<blockquote>
<p>TreeSet 底层树，红黑排序取；<br>
可比必实现 Comparable，自定就传 Comparator；<br>
判重复靠 compare，不是 equals 或 hashCode。</p>
</blockquote>
<h5 id="衍生追问你能说说-hashset-linkedhashset-和-treeset-的区别吗三者对比适用场景是什么"><a class="anchor" href="#衍生追问你能说说-hashset-linkedhashset-和-treeset-的区别吗三者对比适用场景是什么">#</a> 📌 衍生追问：你能说说  <code>HashSet</code> 、 <code>LinkedHashSet</code>  和  <code>TreeSet</code>  的区别吗？三者对比适用场景是什么？</h5>
<h6 id="hashset-vs-linkedhashset-vs-treeset"><a class="anchor" href="#hashset-vs-linkedhashset-vs-treeset">#</a> ✅ HashSet vs LinkedHashSet vs TreeSet</h6>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>HashSet</code></th>
<th><code>LinkedHashSet</code></th>
<th><code>TreeSet</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>底层结构</td>
<td><code>HashMap</code></td>
<td><code>HashMap + 双向链表</code></td>
<td><code>TreeMap（红黑树）</code></td>
</tr>
<tr>
<td>是否有序</td>
<td>❌ 无序</td>
<td>✅ 插入顺序</td>
<td>✅ 自动排序（自然排序或自定义 Comparator）</td>
</tr>
<tr>
<td>是否允许重复</td>
<td>❌ 不允许</td>
<td>❌ 不允许</td>
<td>❌ 不允许</td>
</tr>
<tr>
<td>排序规则</td>
<td>无</td>
<td>按插入顺序</td>
<td>默认按  <code>compareTo()</code> ，也可指定  <code>Comparator</code></td>
</tr>
<tr>
<td>查询效率</td>
<td>✅ 快（O (1)）</td>
<td>✅ 快（O (1)）</td>
<td>⚠ 稍慢（O (log n)）</td>
</tr>
<tr>
<td>插入 / 删除效率</td>
<td>快</td>
<td>较快（略低于 HashSet）</td>
<td>相对较慢</td>
</tr>
<tr>
<td>适用场景</td>
<td>一般场景，追求查询性能</td>
<td>需要保持插入顺序的场景</td>
<td>需要排序（如字典、排行榜）</td>
</tr>
</tbody>
</table>
<hr>
<h6 id="使用建议"><a class="anchor" href="#使用建议">#</a> ✅ 使用建议：</h6>
<ul>
<li><strong>HashSet</strong>：性能最好，用于不关心顺序、只需去重的场景；</li>
<li><strong>LinkedHashSet</strong>：插入顺序敏感，比如缓存、历史记录；</li>
<li><strong>TreeSet</strong>：需要排序输出、快速范围查询的场景，如自然排序、分段查找。</li>
</ul>
<hr>
<h6 id="举个小例子"><a class="anchor" href="#举个小例子">#</a> ✅ 举个小例子：</h6>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> hashSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// [1, 2, 3]（无序）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> linkedSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [3, 2, 1]（插入顺序）</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> treeSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// [1, 2, 3]（自然排序）</span></pre></td></tr></tbody></table></figure><hr>
<h6 id="小结口诀-11"><a class="anchor" href="#小结口诀-11">#</a> ✅ 小结口诀：</h6>
<blockquote>
<p>HashSet 去重快，顺序我不管；<br>
LinkedHashSet 不仅快，顺序我记得；<br>
TreeSet 排序最在行，查找范围选它强。</p>
</blockquote>
<div class="tags"><a href="/tags/Java/" rel="tag"><i class="ic i-tag"></i>Java</a><a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="ic i-tag"></i>面试</a><a href="/tags/ChatGPT/" rel="tag"><i class="ic i-tag"></i>ChatGPT</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2025-07-30 16:34:05" itemprop="dateModified" datetime="2025-07-30T16:34:05+08:00">2025-07-30</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img loading="lazy" data-src="/assets/wechatpay.webp" alt="张大爷 微信支付"><p>微信支付</p></div><div><img loading="lazy" data-src="/assets/alipay.webp" alt="张大爷 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>张大爷<i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong><a href="http://blog.icoders.club/java-interview-basics-01/" title="Java模拟面试题-基础篇-01">http://blog.icoders.club/java-interview-basics-01/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/java-interview-question-02/" rel="prev" itemprop="url" data-background-image="https://i.imgtg.com/2023/03/09/YSj7p.jpg" title="Java模拟面试题（2）"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>面试</span><h3>Java模拟面试题（2）</h3></a></div><div class="item right"><a href="/String-in-Java/" rel="next" itemprop="url" data-background-image="https://i.imgtg.com/2023/03/09/Y0kTl.jpg" title="深入理解 Java 中的 == 和 equals()（面试高频）"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>面试</span><h3>深入理解 Java 中的 == 和 equals()（面试高频）</h3></a></div></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E9%9D%A2%E8%AF%95%E6%A8%A1%E6%8B%9F%E7%B3%BB%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text"> Java 面试模拟系列 🧠📘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text"> 💡Java 基础与进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%981java-%E4%B8%AD-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text"> ❓问题 1：Java 中  ==  和  equals()  的区别？请举例说明。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%8F%AF%E4%BB%8E%E5%A6%82%E4%B8%8B%E8%A7%92%E5%BA%A6%E8%BF%9B%E8%A1%8C%E5%9B%9E%E7%AD%94"><span class="toc-number">2.1.1.</span> <span class="toc-text"> ✨分析：可从如下角度进行回答</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88"><span class="toc-number">2.1.2.</span> <span class="toc-text"> ✅答案：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.2.1.</span> <span class="toc-text"> 🧩 对于基本类型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.2.2.</span> <span class="toc-text"> 🧩 对于引用类型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.2.3.</span> <span class="toc-text"> ✅ 示例代码：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AEstringintern-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E4%B8%8E-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 📌 追问： String.intern()  方法的作用是什么？它与  ==  有什么关系？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.1.3.1.</span> <span class="toc-text"> 🔍 示例代码：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 🧾 总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%982-java-%E7%9A%84%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.</span> <span class="toc-text"> ❓问题 2： Java 的八种基本数据类型是什么？它们各自的默认值是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%E4%B8%BA%E4%BB%80%E4%B9%88-char-%E5%8D%A0%E4%B8%A4%E4%B8%AA%E5%AD%97%E8%8A%82java-%E4%B8%AD%E7%9A%84-char-%E8%83%BD%E8%A1%A8%E7%A4%BA%E5%93%AA%E4%BA%9B%E5%AD%97%E7%AC%A6%E4%BD%A0%E5%AF%B9-unicode-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 📌 追问：为什么  char  占两个字节？Java 中的  char  能表示哪些字符？你对 Unicode 的理解？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">2.2.1.1.</span> <span class="toc-text"> ✨ 分析：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-char-%E5%8D%A0%E4%B8%A4%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">2.2.1.2.</span> <span class="toc-text"> 🔹 为什么  char  占两个字节？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java-%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">2.2.1.3.</span> <span class="toc-text"> 🔹 Java 中使用什么字符编码？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unicode-vs-utf-8-vs-utf-16"><span class="toc-number">2.2.1.4.</span> <span class="toc-text"> 🔹 Unicode vs UTF-8 vs UTF-16</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">2.2.1.5.</span> <span class="toc-text"> 🔍 举个例子：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.2.1.6.</span> <span class="toc-text"> 📌 小结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%983string-stringbuilder-%E5%92%8C-stringbuffer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.</span> <span class="toc-text"> ❓问题 3：String、StringBuilder 和 StringBuffer 有什么区别？它们各自的适用场景？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 🔹 String（不可变对象）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stringbuilder%E5%8F%AF%E5%8F%98%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 🔹 StringBuilder（可变，非线程安全）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stringbuffer%E5%8F%AF%E5%8F%98%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 🔹 StringBuffer（可变，线程安全）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.4.</span> <span class="toc-text"> ✅ 性能对比：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%E8%BF%9B%E9%98%B6%E4%BD%A0%E7%9F%A5%E9%81%93-string-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%90%97%E5%AE%83%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.3.5.</span> <span class="toc-text"> 📌 追问（进阶）：你知道 String 为什么是不可变的吗？它不可变的好处是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-string-%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-number">2.3.5.1.</span> <span class="toc-text"> 🔹 为什么 String 是不可变的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.3.5.2.</span> <span class="toc-text"> 🔒 不可变的好处：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">2.3.5.3.</span> <span class="toc-text"> ✅ 小结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%984java-%E4%B8%AD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E8%AF%B7%E8%A7%A3%E9%87%8A-string-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BC%A0%E5%8F%82%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.4.</span> <span class="toc-text"> ❓问题 4：Java 中是值传递还是引用传递？请解释 String、基本类型、对象类型在方法中的传参行为。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A6%82-int-double-boolean"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 一、基本数据类型（如  int ,  double ,  boolean ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%A6%82-string-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%AD%89"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 二、引用类型（如  String , 自定义对象等）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E7%89%B9%E6%AE%8A%E8%AF%B4%E6%98%8Estring-%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.3.</span> <span class="toc-text"> 三、特殊说明： String  是不可变对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E5%8F%A3%E8%AF%80%E5%8F%AF%E4%BB%A5%E8%83%8C"><span class="toc-number">2.4.4.</span> <span class="toc-text"> ✅ 结论口诀（可以背）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%984%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8B-java-%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%83%BD%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%E5%90%97"><span class="toc-number">2.5.</span> <span class="toc-text"> ❓问题 4：请说一下 Java 中的继承和多态是如何实现的？能举例说明一下吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFinheritance"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 🔷 继承（Inheritance）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81polymorphism"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 🔷 多态（Polymorphism）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD-overload"><span class="toc-number">2.5.2.1.</span> <span class="toc-text"> ✅ 1. 编译时多态（方法重载 Overload）：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-override"><span class="toc-number">2.5.2.2.</span> <span class="toc-text"> ✅ 2. 运行时多态（方法重写 Override）：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E5%8F%A3%E8%AF%80"><span class="toc-number">2.5.3.</span> <span class="toc-text"> ✅ 结论口诀：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-number">2.5.4.</span> <span class="toc-text"> ❗ 补充说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%E8%BF%9B%E9%98%B6"><span class="toc-number">2.5.5.</span> <span class="toc-text"> 📌 追问（进阶）：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E4%BD%86%E6%9C%89%E9%99%90%E5%88%B6"><span class="toc-number">2.5.5.1.</span> <span class="toc-text"> 🔹1. 访问修饰符可以改变，但有限制：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E4%BD%86%E6%9C%89%E9%99%90%E5%88%B6"><span class="toc-number">2.5.5.2.</span> <span class="toc-text"> 🔹2. 异常处理：可以改变，但有限制：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E"><span class="toc-number">2.5.5.3.</span> <span class="toc-text"> ✅ 举个例子说明：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80"><span class="toc-number">2.5.5.4.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%985java-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%88%86%E4%B8%BA%E5%93%AA%E4%B8%A4%E7%B1%BB%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%AE%83%E4%BB%AC%E5%88%86%E5%88%AB%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">2.6.</span> <span class="toc-text"> ❓问题 5：Java 中的异常分为哪两类？如何处理它们？分别举个例子。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%88%86%E4%B8%BA%E4%B8%A4%E7%B1%BB"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 🔷 Java 中的异常分为两类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-checked-exception%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="toc-number">2.6.2.</span> <span class="toc-text"> ✅ 一、Checked Exception（受检异常）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-unchecked-exception%E9%9D%9E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="toc-number">2.6.3.</span> <span class="toc-text"> ✅ 二、Unchecked Exception（非受检异常）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.4.</span> <span class="toc-text"> ✅ 三、异常处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-try-catch-finally"><span class="toc-number">2.6.4.1.</span> <span class="toc-text"> 1. try-catch-finally</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-throws-%E5%85%B3%E9%94%AE%E5%AD%97%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">2.6.4.2.</span> <span class="toc-text"> 2. throws 关键字（方法签名抛出异常）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-throw-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.6.4.3.</span> <span class="toc-text"> 3. throw 抛出异常对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80-2"><span class="toc-number">2.6.5.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE"><span class="toc-number">2.6.6.</span> <span class="toc-text"> 📌 追问：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#finally-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E5%88%99"><span class="toc-number">2.6.6.1.</span> <span class="toc-text"> 🔹  finally  的执行原则：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-3"><span class="toc-number">2.6.6.2.</span> <span class="toc-text"> ✅ 示例代码：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%83%85%E5%86%B51finally-%E6%97%A0-return%E4%B8%8D%E5%BD%B1%E5%93%8D%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.6.6.2.1.</span> <span class="toc-text"> 🎯 情况 1：finally 无 return，不影响返回值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%83%85%E5%86%B52finally-%E6%9C%89-return%E4%BC%9A%E8%A6%86%E7%9B%96-try-%E7%9A%84-return"><span class="toc-number">2.6.6.2.2.</span> <span class="toc-text"> 🎯 情况 2：finally 有 return，会覆盖 try 的 return</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%83%85%E5%86%B53systemexit"><span class="toc-number">2.6.6.2.3.</span> <span class="toc-text"> 🎯 情况 3：System.exit ()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80-3"><span class="toc-number">2.6.6.3.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%986arraylist-%E5%92%8C-linkedlist-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.7.</span> <span class="toc-text"> ❓问题 6：ArrayList 和 LinkedList 有哪些区别？它们各自的适用场景是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-arraylist"><span class="toc-number">2.7.1.</span> <span class="toc-text"> 🔹 1. ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-linkedlist"><span class="toc-number">2.7.2.</span> <span class="toc-text"> 🔹 2. LinkedList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">2.7.3.</span> <span class="toc-text"> ✅ 3. 适用场景对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90-2"><span class="toc-number">2.7.4.</span> <span class="toc-text"> ✅ 举个例子：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%BB%86%E8%8A%82"><span class="toc-number">2.7.5.</span> <span class="toc-text"> 📌 补充细节：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80-4"><span class="toc-number">2.7.6.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AEarraylist-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">2.7.7.</span> <span class="toc-text"> 📌 追问：ArrayList 的扩容机制具体是怎么实现的？初始容量是多少？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">2.7.7.1.</span> <span class="toc-text"> 🔹 1. 默认初始容量是多少？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%89%A9%E5%AE%B9%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.7.7.2.</span> <span class="toc-text"> 🔹 2. 扩容触发条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%A2%9E%E9%95%BF%E8%A7%84%E5%88%99"><span class="toc-number">2.7.7.3.</span> <span class="toc-text"> 🔹 3. 扩容机制（增长规则）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%89%A9%E5%AE%B9%E4%BB%A3%E4%BB%B7%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="toc-number">2.7.7.4.</span> <span class="toc-text"> 🔹 4. 扩容代价（性能影响）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80-5"><span class="toc-number">2.7.7.5.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%987hashmap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88jdk-18-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96"><span class="toc-number">2.8.</span> <span class="toc-text"> ❓问题 7：HashMap 的底层实现原理是什么？JDK 1.8 做了哪些优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-hashmap-%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%8F%98%E5%8C%96"><span class="toc-number">2.8.1.</span> <span class="toc-text"> 🔷 一、HashMap 的底层结构变化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#jdk-17-%E5%8F%8A%E4%BB%A5%E5%89%8D"><span class="toc-number">2.8.1.1.</span> <span class="toc-text"> JDK 1.7 及以前：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jdk-18-%E4%B9%8B%E5%90%8E"><span class="toc-number">2.8.1.2.</span> <span class="toc-text"> JDK 1.8 之后：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E6%A0%B8%E5%BF%83%E6%88%90%E5%91%98%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2"><span class="toc-number">2.8.2.</span> <span class="toc-text"> 🔷 二、核心成员结构（源码层面）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-hashmap-%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8C%96jdk-18"><span class="toc-number">2.8.3.</span> <span class="toc-text"> 🔷 三、HashMap 的主要优化（JDK 1.8）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80-6"><span class="toc-number">2.8.4.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AEhashmap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">2.8.5.</span> <span class="toc-text"> 📌追问：HashMap 是线程安全的吗？并发场景下会出现什么问题？如何解决？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-hashmap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">2.8.5.1.</span> <span class="toc-text"> 🔷 1. HashMap 是线程安全的吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.8.5.2.</span> <span class="toc-text"> 🔷 2. 并发情况下的问题：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.8.5.3.</span> <span class="toc-text"> 🔷 3. 解决方案：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E4%BD%BF%E7%94%A8-collectionssynchronizedmapmap"><span class="toc-number">2.8.5.3.1.</span> <span class="toc-text"> ✅ 方式一：使用  Collections.synchronizedMap(Map) </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E4%BD%BF%E7%94%A8-concurrenthashmap"><span class="toc-number">2.8.5.3.2.</span> <span class="toc-text"> ✅ 方式二：使用  ConcurrentHashMap </span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-concurrenthashmap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BB%A5-jdk-18-%E4%B8%BA%E4%BE%8B"><span class="toc-number">2.8.5.4.</span> <span class="toc-text"> 🔷 4.  ConcurrentHashMap  的底层原理（以 JDK 1.8 为例）：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80-7"><span class="toc-number">2.8.5.5.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E8%BF%BD%E9%97%AE%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E4%BD%A0%E7%9F%A5%E9%81%93-concurrenthashmap-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E6%9D%A5%E5%81%9A-count-%E7%B4%AF%E5%8A%A0%E6%93%8D%E4%BD%9C%E5%90%97%E5%AE%83%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BA%E4%BB%80%E4%B9%88-%E8%BF%98%E6%98%AF%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">2.8.5.6.</span> <span class="toc-text"> 📌 衍生追问（高级面试）：你知道 ConcurrentHashMap 为什么不能用来做 count++ 累加操作吗？它是线程安全的，为什么 ++ 还是不安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0count-%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%AE%83%E5%88%86%E4%B8%89%E6%AD%A5"><span class="toc-number">2.8.5.6.1.</span> <span class="toc-text"> 🔷 原因： count++  并不是原子操作，它分三步：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95"><span class="toc-number">2.8.5.6.2.</span> <span class="toc-text"> 🔷 正确做法 ✅：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80-8"><span class="toc-number">2.8.5.6.3.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%988set-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84hashset-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.9.</span> <span class="toc-text"> ❓问题 8：Set 是如何保证元素不重复的？HashSet 的底层实现原理是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-set-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84"><span class="toc-number">2.9.1.</span> <span class="toc-text"> 🔷 1. Set 是如何保证元素不重复的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-hashset-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.9.2.</span> <span class="toc-text"> 🔷 2. HashSet 的底层原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hashset-%E5%BA%95%E5%B1%82%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA-hashmap"><span class="toc-number">2.9.2.1.</span> <span class="toc-text"> ✅ HashSet 底层其实就是一个  HashMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">2.9.2.2.</span> <span class="toc-text"> ⚠ 注意：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-hashset-%E6%8F%92%E5%85%A5%E8%BF%87%E7%A8%8B%E7%AE%80%E8%BF%B0"><span class="toc-number">2.9.3.</span> <span class="toc-text"> 🔷 3. HashSet 插入过程简述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90-3"><span class="toc-number">2.9.4.</span> <span class="toc-text"> ✅ 举个例子：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80-9"><span class="toc-number">2.9.5.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E9%97%AEtreeset-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%BB%E9%87%8D%E5%92%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%95%E5%B1%82%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%84"><span class="toc-number">2.9.6.</span> <span class="toc-text"> 📌 追问：TreeSet 是如何实现去重和排序的？底层用的是什么结构？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-treeset-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.9.6.1.</span> <span class="toc-text"> 🔷 1. TreeSet 是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-treeset-%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">2.9.6.2.</span> <span class="toc-text"> 🔷 2. TreeSet 的底层结构：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8E%92%E5%BA%8F-%E5%8E%BB%E9%87%8D%E7%9A%84%E4%BE%9D%E6%8D%AE"><span class="toc-number">2.9.6.3.</span> <span class="toc-text"> 🔷 3. 排序 &amp; 去重的依据</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.6.3.1.</span> <span class="toc-text"> 默认排序：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.6.3.2.</span> <span class="toc-text"> 自定义排序：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E7%9A%84%E4%BE%9D%E6%8D%AE"><span class="toc-number">2.9.6.3.3.</span> <span class="toc-text"> 去重的依据：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90-4"><span class="toc-number">2.9.6.4.</span> <span class="toc-text"> ✅ 举个例子：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80-10"><span class="toc-number">2.9.6.5.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E8%BF%BD%E9%97%AE%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4-hashset-linkedhashset-%E5%92%8C-treeset-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.9.6.6.</span> <span class="toc-text"> 📌 衍生追问：你能说说  HashSet 、 LinkedHashSet  和  TreeSet  的区别吗？三者对比适用场景是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#hashset-vs-linkedhashset-vs-treeset"><span class="toc-number">2.9.6.6.1.</span> <span class="toc-text"> ✅ HashSet vs LinkedHashSet vs TreeSet</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.9.6.6.2.</span> <span class="toc-text"> ✅ 使用建议：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E5%B0%8F%E4%BE%8B%E5%AD%90"><span class="toc-number">2.9.6.6.3.</span> <span class="toc-text"> ✅ 举个小例子：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E5%8F%A3%E8%AF%80-11"><span class="toc-number">2.9.6.6.4.</span> <span class="toc-text"> ✅ 小结口诀：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/java-interview-question-01/" rel="bookmark" title="Java模拟面试题（1）">Java模拟面试题（1）</a></li><li><a href="/java-interview-question-02/" rel="bookmark" title="Java模拟面试题（2）">Java模拟面试题（2）</a></li><li class="active"><a href="/java-interview-basics-01/" rel="bookmark" title="Java模拟面试题-基础篇-01">Java模拟面试题-基础篇-01</a></li><li><a href="/String-in-Java/" rel="bookmark" title="深入理解 Java 中的 == 和 equals()（面试高频）">深入理解 Java 中的 == 和 equals()（面试高频）</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="张大爷" src="/assets/avatar.webp"><p class="name" itemprop="name">张大爷</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">7</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">13</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/admin-zhang" class="item github" title="https://github.com/admin-zhang"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://gitee.com/admin-zhang" class="item gitee" title="https://gitee.com/admin-zhang"><i class="ic i-gitee"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/links" rel="section"><i class="ic i-magic"></i>链接</a></li><li class="item"><a href="/stat" rel="section"><i class="ic i-stat"></i>统计</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/String-in-Java/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/java-interview-question-02/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/course/" title="分类于教程">教程</a><i class="ic i-angle-right"></i><a href="/categories/course/Linux/" title="分类于Linux">Linux</a><i class="ic i-angle-right"></i><a href="/categories/course/Linux/Git/" title="分类于Git">Git</a></div><span><a href="/installGitOnLinux/">Linux中手动安装Git</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/java/interview/" title="分类于面试">面试</a></div><span><a href="/java-interview-question-02/">Java模拟面试题（2）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/java/interview/" title="分类于面试">面试</a></div><span><a href="/java-interview-basics-01/">Java模拟面试题-基础篇-01</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/java/interview/" title="分类于面试">面试</a></div><span><a href="/java-interview-question-01/">Java模拟面试题（1）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/course/" title="分类于教程">教程</a><i class="ic i-angle-right"></i><a href="/categories/course/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/course/java/arrange/" title="分类于项目部署">项目部署</a></div><span><a href="/Linux%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2SpringBoot-Vue%E9%A1%B9%E7%9B%AE/">Linux系统部署SpringBoot+Vue项目</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于数据库">数据库</a></div><span><a href="/%E9%AB%98%E9%A2%91%20SQL%2050%20%E9%A2%98%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/">高频 SQL 50 题（基础版）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/java/interview/" title="分类于面试">面试</a></div><span><a href="/String-in-Java/">深入理解 Java 中的 == 和 equals()（面试高频）</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><div class="status"><div class="copyright">© 2025 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">张大爷 @ 碎银几两</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">109k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">1:39</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> &amp; Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div><br><span style="display:inline;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:var(--grey-5);"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">京ICP备2023036429号</a><br><a target="_blank" href="https://beian.mps.gov.cn/#/query/webSearch?code=11011402053974"><img loading="lazy" decoding="async" data-src="/assets/ICP.webp" style="max-width: 2em;display:inline;" width="20" height="20" alt="备案">京公网安备11011402053974号</a></span><div style="width: 100%; text-align: center;"><span id="time">此站已存活 0 天 00 小时 00 分 00 秒</span></div><script>function createtime() {
    const createTime = new Date("2025/07/25 00:00:00"); // 确保这个值可被 JS 识别
    const now = new Date();
    const diff = (now - createTime) / 1000;

    const dnum = Math.floor(diff / (60 * 60 * 24));
    const hnum = String(Math.floor((diff / (60 * 60)) % 24)).padStart(2, '0');
    const mnum = String(Math.floor((diff / 60) % 60)).padStart(2, '0');
    const snum = String(Math.floor(diff % 60)).padStart(2, '0');

    document.getElementById("time").innerHTML =
        `此站已存活 ${dnum} 天 ${hnum} 小时 ${mnum} 分 ${snum} 秒`;
}

setInterval(createtime, 1000);</script></div><script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script><div id="busuanzi-wrap"><span class="ic i-eye"></span><span id="busuanzi_container_site_pv">本站访问量 <span id="busuanzi_value_site_pv"></span> 次</span> | <span class="ic i-user"></span><span id="busuanzi_container_site_uv">本站访客量 <span id="busuanzi_value_site_uv"></span> 次</span></div></div></footer></div><script data-config="" type="text/javascript">var LOCAL = {
    ispost: true,
        path: `java-interview-basics-01/`,
        favicon: {
        show: `不负韶华`,
        hide: `以梦为马！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: ["https://music.163.com/song?id=1387098940"],
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/pace/1.2.4/pace.min.js" async=""></script><script src="/js/siteInit.js?v=0.4.2" type="module" fetchpriority="high" defer=""></script></body></html>